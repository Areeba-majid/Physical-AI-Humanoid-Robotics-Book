"""Chapter service for the AI textbook platform."""

from typing import List, Optional
from datetime import datetime

from src.models.chapter import Chapter, ChapterCreate, ChapterUpdate
from src.database.repository import BaseRepository
from src.utils.exceptions import ChapterNotFoundException
from src.utils.logging import log_db_operation


class ChapterRepository(BaseRepository[Chapter]):
    """Repository for chapter operations."""
    
    def __init__(self):
        super().__init__(Chapter, "chapters")
    
    async def get_by_order_index(self, order_index: int) -> Optional[Chapter]:
        """Get a chapter by its order index."""
        return await self.find_one({"order_index": order_index})
    
    async def get_published_chapters(self, skip: int = 0, limit: int = 100) -> List[Chapter]:
        """Get all published chapters with pagination."""
        chapters = await self.find_many({"status": "published"})
        # Apply pagination
        return chapters[skip:skip + limit]
    
    async def get_chapters_by_language(self, language: str = "en") -> List[Chapter]:
        """Get chapters by language (language-specific content coming from content or content_ur)."""
        # This is a simplified implementation - in a real app, you might have
        # a different approach for language-specific content
        return await self.find_all()


class ChapterService:
    """Service layer for chapter operations."""
    
    def __init__(self):
        self.repository = ChapterRepository()
    
    async def get_all_chapters(self, skip: int = 0, limit: int = 100) -> List[Chapter]:
        """Get all chapters with pagination."""
        chapters = await self.repository.find_all(skip=skip, limit=limit)
        log_db_operation("find_all", "chapters", context={"count": len(chapters), "skip": skip, "limit": limit})
        return chapters
    
    async def get_chapter_by_id(self, chapter_id: str) -> Chapter:
        """Get a chapter by its ID."""
        chapter = await self.repository.find_by_id(chapter_id)
        if not chapter:
            raise ChapterNotFoundException(chapter_id)
        
        log_db_operation("find_by_id", "chapters", context={"chapter_id": chapter_id})
        return chapter
    
    async def get_chapter_by_order_index(self, order_index: int) -> Chapter:
        """Get a chapter by its order index."""
        chapter = await self.repository.get_by_order_index(order_index)
        if not chapter:
            raise ChapterNotFoundException(f"chapter_with_order_{order_index}")
        
        log_db_operation("find_by_order", "chapters", context={"order_index": order_index})
        return chapter
    
    async def create_chapter(self, chapter_create: ChapterCreate) -> Chapter:
        """Create a new chapter."""
        # Calculate word count if not provided
        if chapter_create.word_count is None:
            chapter_create.word_count = len(chapter_create.content.split())
        
        # Calculate reading time estimate if not provided (assuming 200 words per minute)
        if chapter_create.reading_time_estimate is None and chapter_create.word_count:
            chapter_create.reading_time_estimate = max(1, chapter_create.word_count // 200)
        
        # Prepare the chapter object
        chapter = Chapter(
            id="",  # Will be generated by the repository
            title=chapter_create.title,
            content=chapter_create.content,
            content_ur=chapter_create.content_ur,
            sections=chapter_create.sections,
            order_index=chapter_create.order_index,
            word_count=chapter_create.word_count,
            reading_time_estimate=chapter_create.reading_time_estimate,
            associated_quiz_id=chapter_create.associated_quiz_id,
            status=chapter_create.status,
            metadata=chapter_create.metadata,
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow()
        )
        
        # Save to database
        created_chapter = await self.repository.create(chapter)
        log_db_operation("create", "chapters", context={"chapter_id": created_chapter.id})
        return created_chapter
    
    async def update_chapter(self, chapter_id: str, chapter_update: ChapterUpdate) -> Chapter:
        """Update an existing chapter."""
        chapter = await self.repository.find_by_id(chapter_id)
        if not chapter:
            raise ChapterNotFoundException(chapter_id)
        
        # Prepare update data
        update_data = chapter_update.dict(exclude_unset=True)
        update_data["updated_at"] = datetime.utcnow()
        
        # Recalculate word count and reading time if content is updated
        if "content" in update_data and chapter_update.content:
            if "word_count" not in update_data or update_data["word_count"] is None:
                update_data["word_count"] = len(chapter_update.content.split())
            if ("reading_time_estimate" not in update_data or 
                update_data["reading_time_estimate"] is None) and update_data["word_count"]:
                update_data["reading_time_estimate"] = max(1, update_data["word_count"] // 200)
        
        updated_chapter = await self.repository.update(chapter_id, update_data)
        log_db_operation("update", "chapters", context={"chapter_id": chapter_id})
        return updated_chapter
    
    async def delete_chapter(self, chapter_id: str) -> bool:
        """Delete a chapter by its ID."""
        success = await self.repository.delete(chapter_id)
        if not success:
            raise ChapterNotFoundException(chapter_id)
        
        log_db_operation("delete", "chapters", context={"chapter_id": chapter_id})
        return success
    
    async def get_published_chapters(self, skip: int = 0, limit: int = 100) -> List[Chapter]:
        """Get all published chapters with pagination."""
        chapters = await self.repository.get_published_chapters(skip, limit)
        log_db_operation("find_published", "chapters", context={"count": len(chapters), "skip": skip, "limit": limit})
        return chapters
    
    async def get_next_chapter(self, current_chapter_order: int) -> Optional[Chapter]:
        """Get the next chapter after the current one."""
        next_order = current_chapter_order + 1
        return await self.repository.get_by_order_index(next_order)
    
    async def get_previous_chapter(self, current_chapter_order: int) -> Optional[Chapter]:
        """Get the previous chapter before the current one."""
        if current_chapter_order <= 1:
            return None
        
        prev_order = current_chapter_order - 1
        return await self.repository.get_by_order_index(prev_order)